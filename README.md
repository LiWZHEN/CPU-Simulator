# Tomasulo CPU Simulator

#### -------------------------------------------------------------------------- livandan 2025.7

## 元件
- Memory
- PC
- Decoder
- RoB
- RS
- LSB
- RF
- ALU

## 各元件操作

### Memory
#### 连接元件
* 组合：PC
* 时序：Decoder, RoB, RS, LSB
#### 更新操作
* 把暂存区中上一周期收到的信息搬到工作区，把暂存区置空
#### 运行操作
* 如果上个周期收到的是 Load 类型任务，读出指定地址的值，和 RoB 编号一起发送给 RoB 与 RS 和 LSB
* 如果上个周期收到的是 Store 类型任务，根据收到的地址和值，修改内存

### ProgramCounter
#### 连接元件
* 组合：Memory
* 时序：Decoder
#### 更新操作
* 把暂存区中的指令搬运到工作区，重置暂存区
#### 运行操作
* 以下情况需要在本周期读取数据前强制修改 PC 到指定位置：
  * RoB 上一周期发来分支预测错误信号以及另一分支在内存中的位置
  * Decoder 上一周期解码的是 B 类型指令，预测应该跳转，把目标位置传给 PC
  * Decoder 上一周期解码的是 JAL ，把目标位置传给 PC
  * PC 正在等待 JALR 结果，ALU 上一周期计算得到目标地址值之后，通知 PC 跳转位置并且解除等待状态
* 发送机器码
  * 如果 PC 在等待状态
    * 告诉 Decoder 下个周期没有需要解码的指令（发送0手动置空，防止指令重复发射），不需要移动 PC 位置
  * 如果 PC 不在等待状态
    * 如果收到 RoB 已满的信号，不发送机器码（避免覆盖上个周期指令的机器码），不移动 PC
    * 如果没有 RoB 已满的信号，从当前 PC 所指向的地址的 memory 中取出机器码并发送给 Decoder，同时把当前 PC 位置发送给 Decoder（ B 类型指令、JAL、JALR、AUIPC 指令需要用到），移动 PC 到 PC + 4

### Decoder
#### 连接元件
* 组合：Predictor
* 时序：PC, RoB, RS, LSB, RF
#### 更新操作
* 如果上一周期接收到分支预测错误信号，设置工作区分支预测错误标志，把暂存区全部清空
* 如果上一周期未接收到分支预测错误信号
  * 如果收到丢弃当前任务信号
    * 清空暂存区,把工作区机器码设为空
  * 如果未收到丢弃当前任务信号
    * 如果收到 RoB / LSB 已满信号，把工作区清空，不把暂存区信息搬运至工作区，只重置接收 commit 信息的位置，以便接收新的 commit 信息
    * 如果没有收到 RoB / LSB 已满信号，正常把暂存区信息移到工作区，重置暂存区
#### 运行操作
* 如果接收到分支预测错误信号，或者 machine code 为 0，给 RoB、RS、LSB 均发送空信号
* 如果当前机器码对应退出指令，只给 RoB 发送类型为 EXIT 的指令信息，给 PC 发送等待信号让 PC 停止移动
* 解码
  * 特判：如果要写入寄存器 X0，不往 RoB 中提交
* 获取并更新依赖关系
  * 从 RF 发来的信息中得到要读的寄存器的依赖 Q1 与 Q2，若不存在依赖，把值发给 RS
  * 尝试使用 RoB 中已经准备好但未提交的值去除依赖关系
  * 检查上一条指令是否建立本指令的新依赖，若是，把对应依赖改成上一条指令的 RoB index
* 要是解码结果需要 PC 跳转，设置丢弃这个周期接收到的信息，并告知 PC 等待（JALR）或跳转位置（B）
* 传输
  * -> RoB: 指令类型、要写回的寄存器编号、操作值（如果操作值是立即数，应告知is_ready为true）
  * -> RS: 指令类型、V1、V2、Q1、Q2、RoB 中位置、需要读取的 rs1 和 rs2（若不存在，传-1）
  * -> LSB: 
    * 如果操作是Store: 指令类型、该指令在RoB中的序号、还未被commit、访存周期未开始（设为-1）
    * 如果操作是Load: 指令类型、操作值、该指令对应的RoB序号、操作值是否准备好

### RoB
#### 连接元件
* 组合：Predictor
* 时序：RS, LSB, Decoder, RF, PC, ALU
#### 更新操作
* 如果收到上周期自己传来的分支预测错误信号，把工作区和暂存区的信号全部重置（仅保留工作区的分支预测错误信号）
* 如果上周期正常提交，把暂存区信息搬到工作区，重置暂存区
#### 运行操作
* 检查分支预测错误信号
  * 若有：清空，告知 RF 没有产生新依赖（之所以不用告诉 RS 与 Decoder 是因为它们本周期也会收到分支预测错误信号并停止工作）
* 根据 ALU 计算结果更新值，把状态设为已准备好
  * 若指令为 B 类型，把原值左移一位，最低位放预测结果是否正确（0：错误，1：正确）
  * 若指令为除 Load 外（ALU 不会给 RoB 传 Load 类型的计算结果）的其他类型，把计算结果填入 v
* 把从 Decoder 传来的指令填入序列末尾
  * 如果指令是 B / S 类型，或是 Decoder 传来空指令，告知 RF、RS、Decoder 本周期并未产生新依赖
  * 若指令为其他类型，把新产生的依赖传给 RF、RS 和 Decoder
* 检查上个周期是否有 Load，若有，设置对应指令的值，把状态改为已准备好
* 把更新后、commit 前的 RoB 发给 RS、LSB、Decoder（其实可以不发给 Decoder，因为在 Decoder 中能用 RoB 清除的依赖，在 RS 和 LSB 中必定能用 RoB 清除）
* 提交
  * 从队头开始检查，依次提交并移除队头已经准备好的指令，遇到未准备好的指令终止本次 commit【特例：如果在提交一些普通指令后，需要提交分支预测错误或者终止指令，应提前结束本次提交，等到下一周期再提交分支预测错误（必须等一周期！否则，如果在分支预测错误指令提交的同一周期提交了 S 指令，在 LSB 清除未 commit 的 S 指令时，该 S 指令的状态还未更新，会导致误删）或终止指令（可以直接结束，不影响正确性）】
  * Branch:
    * 判断正确：继续操作，给Predictor一个反馈
    * 判断错误：
      * -> 给RoB本身、RS、LSB、Decoder、RF、ALU发送分支预测错误信号
      * -> 给PC发送分支预测错误信号和跳转目标位置
      * -> 给Predictor一个反馈
      * 终止本次提交
  * 其他指令类型:
    * -> RF: 指令类型、值、地址、提交的指令在RoB中的编号
* 向 RS、LSB 传输当前 tail 位置
* 如果当前 RoB 大小不小于 30，向 Decoder 和 PC 发送 RoB 将满的信号

### ALU
#### 连接元件
* 时序：RoB, RS, LSB, PC
#### 运行操作
* 如果接收到分支预测错误信号，丢弃当前Task
* 计算
* 传输

      计算操作：
        -> RoB & RS & LSB: 指令类型、哪个位置、值是多少
      Jalr:
        -> PC: 解除等待状态，下一步跳转到什么位置
      Load:
        -> LSB: 指令类型、计算出的地址、对应的RoB位置（寄存器状态不变所以不用广播）
      Store:
        -> RoB: 指令类型、哪个位置、计算出的地址（不可能有指令依赖Store所以只要修改不用广播）
* 更新

      用被RS设置的新任务更新操作种类、操作数、操作对应RoB编号

### RF
#### 连接元件
* 时序： Decoder
#### 运行操作
* 检查分支预测错误信号

      若有：清空依赖
* 传输

      -> Decoder: 当前寄存器值和依赖
* 更新

      根据RoB传来的修改信号更新寄存器值、清除对应依赖关系
      根据Decoder传来的信号添加/更新依赖关系

### RS
#### 连接元件
* 时序：ALU
#### 运行操作
* 检查分支预测错误信号：

      若有：清空
* 更新

      取出上一周期Decoder传来的指令类型、运算数、依赖和RoB传来的地址
      在RoB传来的值和依赖中检查有没有计算好但是未commit的、本指令需要的寄存器值，如有，进行值更新与依赖清除
      把处理后信息填入RS空位（is_busy为false）中，把is_busy设为true
* 检查是否有指令已经没有依赖

      如果有：把指令类型、两个运算数、目标值应该写回到RoB的位置传到ALU，把这行指令清除（is_busy设为false）
      如果没有：给ALU传一个NONE
* 检查是否有load信号

      如果有：把所有对应load相关依赖的值更新，清除依赖
### LSB
#### 连接元件
* 时序：Memory
#### 运行操作
* 检查分支预测错误信号

      若有：清空task与未commit部分
* 更新

      取出上一周期Decoder传来的指令类型、数据、依赖和RoB传来的地址
      在RoB传来的值和依赖中检查有没有计算好但是未commit的、本指令需要的寄存器值，如有，进行值更新与依赖清除
* 从头到尾检查指令

      Load: 已开始操作：时间--，若时间变为0，给memory发送一个Load信号，清除指令（head--），继续向下检查
            已准备好但未开始操作：时间设为1，终止向下检查
      Store: 已开始操作：时间--，若时间变为0，给memory发送一个Store信号，清除指令（head--），继续向下检查
             已准备好且已commit但未开始操作：时间设为1，终止向下检查
* 检查是否有load信号

      如果有：把所有对应load相关依赖的值更新，清除依赖
      把处理后信息填入tail位置，tail++