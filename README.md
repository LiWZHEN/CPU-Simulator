# Tomasulo CPU Simulator

#### -------------------------------------------------------------------------- livandan 2025.7

## 元件
- Memory
- PC
- Decoder
- RoB
- RS
- LSB
- RF
- ALU

## 各元件操作

### Memory
#### 连接元件
* 组合：PC
* 时序：Decoder, RoB, RS, LSB
#### 更新操作
* 把暂存区中上一周期收到的信息搬到工作区，把暂存区置空
#### 运行操作
* 如果上个周期收到的是 Load 类型任务，读出指定地址的值，和 RoB 编号一起发送给 RoB 与 RS 和 LSB
* 如果上个周期收到的是 Store 类型任务，根据收到的地址和值，修改内存

### ProgramCounter
#### 连接元件
* 组合：Memory
* 时序：Decoder
#### 更新操作
* 把暂存区中的指令搬运到工作区，重置暂存区
#### 运行操作
* 以下情况需要在本周期读取数据前强制修改 PC 到指定位置：
  * RoB 上一周期发来分支预测错误信号以及另一分支在内存中的位置
  * Decoder 上一周期解码的是 B 类型指令，预测应该跳转，把目标位置传给 PC
  * Decoder 上一周期解码的是 JAL ，把目标位置传给 PC
  * PC 正在等待 JALR 结果，ALU 上一周期计算得到目标地址值之后，通知 PC 跳转位置并且解除等待状态
* 发送机器码
  * 如果 PC 在等待状态
    * 告诉 Decoder 下个周期没有需要解码的指令（发送0手动置空，防止指令重复发射），不需要移动 PC 位置
  * 如果 PC 不在等待状态
    * 如果收到 RoB 已满的信号，不发送机器码（避免覆盖上个周期指令的机器码），不移动 PC
    * 如果没有 RoB 已满的信号，从当前 PC 所指向的地址的 memory 中取出机器码并发送给 Decoder，同时把当前 PC 位置发送给 Decoder（ B 类型指令、JAL、JALR、AUIPC 指令需要用到），移动 PC 到 PC + 4

### Decoder
#### 连接元件
* 组合：Predictor
* 时序：PC, RoB, RS, LSB, RF
#### 更新操作
* 如果上一周期接收到分支预测错误信号，设置工作区分支预测错误标志，把暂存区全部清空
* 如果上一周期未接收到分支预测错误信号
  * 如果收到丢弃当前任务信号
    * 清空暂存区,把工作区机器码设为空
  * 如果未收到丢弃当前任务信号
    * 如果收到 RoB / LSB 已满信号，把工作区清空，不把暂存区信息搬运至工作区，只重置接收 commit 信息的位置，以便接收新的 commit 信息
    * 如果没有收到 RoB / LSB 已满信号，正常把暂存区信息移到工作区，重置暂存区
#### 运行操作
* 如果接收到分支预测错误信号，或者 machine code 为 0，给 RoB、RS、LSB 均发送空信号
* 如果当前机器码对应退出指令，只给 RoB 发送类型为 EXIT 的指令信息，给 PC 发送等待信号让 PC 停止移动
* 解码
  * 特判：如果要写入寄存器 X0，不往 RoB 中提交
* 获取并更新依赖关系
  * 从 RF 发来的信息中得到要读的寄存器的依赖 Q1 与 Q2，若不存在依赖，把值发给 RS
  * 尝试使用 RoB 中已经准备好但未提交的值去除依赖关系
  * 检查上一条指令是否建立本指令的新依赖，若是，把对应依赖改成上一条指令的 RoB index
* 要是解码结果需要 PC 跳转，设置丢弃这个周期接收到的信息，并告知 PC 等待（JALR）或跳转位置（B）
* 传输
  * -> RoB: 指令类型、要写回的寄存器编号、操作值（如果操作值是立即数，应告知is_ready为true）
  * -> RS: 指令类型、V1、V2、Q1、Q2、RoB 中位置、需要读取的 rs1 和 rs2（若不存在，传-1）
  * -> LSB: 
    * 如果操作是Store: 指令类型、该指令在RoB中的序号、还未被commit、访存周期未开始（设为-1）
    * 如果操作是Load: 指令类型、操作值、该指令对应的RoB序号、操作值是否准备好

### RoB
#### 连接元件
* 组合：Predictor
* 时序：RS, LSB, Decoder, RF, PC, ALU
#### 更新操作
* 如果收到上周期自己传来的分支预测错误信号，把工作区和暂存区的信号全部重置（仅保留工作区的分支预测错误信号）
* 如果上周期正常提交，把暂存区信息搬到工作区，重置暂存区
#### 运行操作
* 检查分支预测错误信号
  * 若有：清空，告知 RF 没有产生新依赖（之所以不用告诉 RS 与 Decoder 是因为它们本周期也会收到分支预测错误信号并停止工作）
* 根据 ALU 计算结果更新值，把状态设为已准备好
  * 若指令为 B 类型，把原值左移一位，最低位放预测结果是否正确（0：错误，1：正确）
  * 若指令为除 Load 外（ALU 不会给 RoB 传 Load 类型的计算结果）的其他类型，把计算结果填入 v
* 把从 Decoder 传来的指令填入序列末尾
  * 如果指令是 B / S 类型，或是 Decoder 传来空指令，告知 RF、RS、Decoder 本周期并未产生新依赖
  * 若指令为其他类型，把新产生的依赖传给 RF、RS 和 Decoder
* 检查上个周期是否有 Load，若有，设置对应指令的值，把状态改为已准备好
* 把更新后、commit 前的 RoB 发给 RS、LSB、Decoder（其实可以不发给 Decoder，因为在 Decoder 中能用 RoB 清除的依赖，在 RS 和 LSB 中必定能用 RoB 清除）
* 提交
  * 从队头开始检查，依次提交并移除队头已经准备好的指令，遇到未准备好的指令终止本次 commit【特例：如果在提交一些普通指令后，需要提交分支预测错误或者终止指令，应提前结束本次提交，等到下一周期再提交分支预测错误（必须等一周期！否则，如果在分支预测错误指令提交的同一周期提交了 S 指令，在 LSB 清除未 commit 的 S 指令时，该 S 指令的状态还未更新，会导致误删）或终止指令（可以直接结束，不影响正确性）】
  * Branch:
    * 判断正确：继续操作，给 Predictor 一个反馈
    * 判断错误：
      * -> 给 RoB 本身、RS、LSB、Decoder、RF、ALU发送分支预测错误信号
      * -> 给 PC 发送分支预测错误信号和跳转目标位置
      * -> 给 Predictor 一个反馈
      * 终止本次提交
  * 其他指令类型:
    * -> RF: 指令类型、值、地址、提交的指令在RoB中的编号
* 向 RS、LSB 传输当前 tail 位置
* 如果当前 RoB 大小不小于 30，向 Decoder 和 PC 发送 RoB 将满的信号


### RS
#### 连接元件
* 时序：ALU
#### 更新操作
* 把暂存区所有数据搬到工作区，重置暂存区
#### 运行操作
* 若上一周期传来分支预测错误信号，清空 RS，给 ALU 传一个空任务
* 若上一周期 Decoder 传来一个非空指令，尝试用上一周期得到的 RoB 更新依赖，之后检查上一周期新建立依赖的寄存器是否恰好是本指令需要的，若是，更新依赖
* 用 ALU 的广播更新 RS 中的依赖
* 用 Load 的广播更新 RS 中的依赖
* 从 RS 中取一条已经没有依赖的指令发送给 ALU，并从 RS 中移除这条指令，若所有指令都存在依赖，给 ALU 发空指令

### LSB
#### 连接元件
* 时序：Memory, Decoder, PC
#### 更新操作
* 把暂存区所有信息搬到工作区，重置暂存区
#### 运行操作
* 对每一条从 RF 发来的 Store 指令，找到它在 LSB 中的位置，更新目标地址和要存的值，把状态设为 committed
* 检查分支预测错误信号
  * 若有分支预测错误信号：从头开始检查 LSB，丢弃找到的第一条 Load 指令 / 未 commit 的 Store 指令及其后的所有指令
  * 若没有分支预测错误信号：若 Decoder 传来非空指令，把指令加到 LSB 尾部
* 若 ALU 传来的是 Load 指令的计算结果，用它更新对应指令的地址，把状态设为已准备好
* 若 LSB 的第一条指令已经准备好：
  * 若这是访存操作的第一个周期（cycle 为 -1），把 cycle 设为 2
  * 否则 cycle--，若 cycle 减为 0，把指令种类、目标地址、指令在 RoB 中的位置（Load）/ 要存的值（Store）传给 Memory，随后把这条指令从 LSB 中移除
* 检查 LSB 当前大小，若不小于 30，向 Decoder 和 PC 发送将满信号（类似 RoB 将满）

### RF
#### 连接元件
* 时序： Decoder, LSB
#### 更新操作
* 把所有暂存区信息搬到工作区，重置暂存区
#### 运行操作
* 对于每一条从 RoB commit 来的指令：
  * 检查每一个寄存器的依赖是否为该指令（看RoB编号），若是，把依赖清除
  * 检查指令种类
    * 是 S 指令：给 LSB 传目标地址、要存的数据、指令在 RoB 中的位置
    * 不是 S 指令：把寄存器 rd 的值修改为 RoB 指令的值
  * 根据 RoB 传来的新建立的依赖关系，更新对应寄存器的依赖
  * 如果上一周期传来分支预测错误信号，把所有寄存器依赖清空

### ALU
#### 连接元件
* 时序：RoB, RS, LSB, PC
#### 更新操作
* 如果上一周期传来分支预测错误信号，把工作区和暂存区都重置，否则把暂存区的指令种类、在 RoB 中的序号、两个操作数移到工作区
#### 运行操作
* 如果任务为空（包括因为上一周期传来分支预测错误信号而被清空的情况），给 RoB、RS、LSB 传一个空信号，直接返回
* 计算操作、LUI、AUIPC、JAL：
  * -> RoB & RS & LSB: 指令类型、计算结果、指令在 RoB 中的位置
* Load:
  * -> LSB: 指令类型、计算出的地址、对应的 RoB 位置（寄存器状态不变所以不用广播）
* Store:
  * -> RoB: 指令类型、哪个位置、计算出的地址（不可能有指令依赖 Store 所以只要修改不用广播）
* Branch:
  * -> RoB: 指令类型、判断结果（0：不应该跳转，1：应该跳转）、指令在 RoB 中的位置
* Jalr:
  * -> PC: 下一步跳转的目标位置，并解除等待状态